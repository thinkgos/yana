# 二. 数据持久化

Redis 的持久化主要有两大机制，即 **AOF(Append Only File)日志**和**RDB快照(Redis Dababase)**

## 1. AOF日志

不同于数据库的写前日志(Write Ahead Log, WAL), AOF日志正好相反,它是写后日志,指的是先执行命令, 然后才记录日志.且只有执行成功的命令才会被记录且不会对命令的语法进行检查.

AOF命令格式:

> 以 `set testkey testvalue`为例
>
> AOF文件:
>
> ```
> *3
> $3
> set
> $7
> testkey
> $9
> testvalue
> ```
>
> `*3`: 表示当前命令有三个部份
>
> `$+数字`: 表示后面紧跟的命令,键或值的字节数.

#### 1.1 AOF三个种写回策略

`AOF` 机制给我们提供了三个选择，也就是 AOF 配置项 `appendfsync` 的三个可选值。

- **Always**，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；
- **Everysec**，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
- **No**，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。

![image-20220611084029670](http://imgur.thinkgos.cn/imgur/202206110840875.png)

#### 1.2 AOF重写机制

控制AOF重写的触发时机：

- `auto-aof-rewrite-min-size`: 表示运行AOF重写时文件的最小大小，默认为64MB 
- `auto-aof-rewrite-percentage:` 这个值的计算方法是：当前AOF文件大小和上一次重写后AOF文件大小的差值，再除以上一次重写后AOF文件大小。也就是当前AOF文件比上一次重写后AOF文件的增量大小，和上一次重写后AOF文件大小的比值。
- 手动发送`bgrewriteaof`指令

AOF 重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。重写机制具有“多变一”功能。所谓的“多变一”，也就是说，旧日志文件中的多条命令，在重写后的新日志中变成了一条命令.

> 和 AOF 日志由主线程写回不同，重写过程是由后台子进程 `bgrewriteaof` 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。

每次 AOF 重写时(**一个拷贝，两处日志**)，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志(AOF缓冲日志和AOF重写缓冲日志)保证在重写过程中，拷贝数据写完后,会把AOF重写缓冲日志记录到新的AOF文件, 这样新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。

![img](http://imgur.thinkgos.cn/imgur/202206111037371.jpeg)

## 2. RDB - Redis DataBase

对 Redis 来说，它实现类似照片记录效果的方式，就是把某一时刻的状态以文件的形式写到磁盘上，也就是快照。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 RDB 文件，其中，RDB 就是 Redis DataBase 的缩写。

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。

- **save**：在主线程中执行，会导致阻塞；
- **bgsave**：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的**默认配置**。

Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作.

>  简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。
> 如果发生写,则复制被修改的那份数据,将其写入RDB文件.
> 先做全量快照,然后再做**增量快照**.
>
> 混合使用 AOF 日志和内存快照的方法,AOF 日志也只用记录两次快照间的操作.



